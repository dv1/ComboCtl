package info.nightscout.comboctl.base

import kotlinx.coroutines.*
import kotlinx.coroutines.channels.Channel

private val logger = Logger.get("MainControl")

/**
 * Main interface for controlling Combo pumps via ComboCtl.
 *
 * This is the high level interface for using ComboCtl.
 * Programs primarily use this class, along with [Pump].
 *
 * This class takes care of managing pump discovery via
 * Bluetooth and performing the pairing once a pump is
 * discovered, along with connecting to pumps.
 */
class MainControl(
    private val bluetoothInterface: BluetoothInterface,
    private val requestPersistentState: (newPumpAddress: BluetoothAddress) -> PersistentState,
    private val pairingPINCallback: (
        newPumpAddress: BluetoothAddress,
        previousAttemptFailed: Boolean,
        getPINDeferred: CompletableDeferred<PairingPIN>
    ) -> Unit
) {
    private var discoveryEventLoopJob: Job? = null

    private enum class EventType {
        NEW_PUMP,
        PUMP_GONE
    }

    private val discoveryEventChannel = Channel<Pair<BluetoothAddress, EventType>>(Channel.UNLIMITED)

    init {
        logger(LogLevel.INFO) { "Main control started" }
    }

    /**
     * Starts Bluetooth discovery to look for unpaired pumps.
     *
     * This manages the Bluetooth device discovery and the pairing
     * process with new pumps. Once an unpaired pump is discovered,
     * the Bluetooth implementation pairs with it, using the
     * [Constants.BT_PAIRING_PIN] PIN code (not to be confused with
     * the 10-digit Combo PIN). The discovery process runs in the
     * background in the supplied [backgroundDiscoveryEventScope].
     * When the Bluetooth pairing is done, the Combo specific pairing
     * is performed using [Pump.performPairing]. The pairing process
     * fills a [PersistentState] instance specific to the discovered
     * pump. Said state is retrieved by calling [requestPersistentState].
     * Once pairing is done, that state will have been filled with
     * pairing data (cipher keys etc.), and a regular connection can
     * be established with the pump.
     *
     * [backgroundReceiveScope]'s context needs to be associated with
     * the same thread this function is called in. Otherwise, the receive
     * loop may run in a different thread than this function, potentially
     * leading to race conditions.
     *
     * @param backgroundReceiveScope [CoroutineScope] to run the
     *        background pairing activities in.
     * @param onNewPump Optional callback to notify callers about a new
     *        pump. It is not required to set this for a successful
     *        pairing; this is purely for notification.
     * @param onPumpGone Optional callback to notify callers that a
     *        previously Bluetooth-level paired pump is now gone.
     *        Typically, this happens because the pump is out of range,
     *        or because the user unpaired it in the Bluetooth settings,
     *        or when the pump is turned off.
     * @throws IllegalStateException if a discovery is already ongoing.
     * @throws BluetoothException if discovery fails due to an underlying
     *         Bluetooth issue.
     */
    fun startDiscovery(
        backgroundDiscoveryEventScope: CoroutineScope,
        onNewPump: (pumpAddress: BluetoothAddress) -> Unit = { Unit },
        onPumpGone: (pumpAddress: BluetoothAddress) -> Unit = { Unit }
    ) {
        if (discoveryEventLoopJob != null)
            throw IllegalStateException("Discovery already ongoing")

        logger(LogLevel.DEBUG) { "Starting discovery" }

        // Discovery events may be generated by a separate background
        // thread depending on the Bluetooth implementation. For this
        // reason, the event callbacks are not called directly when
        // an event occurs. Instead, they are serialized into the
        // discoveryEventChannel. In the loop here, we listen for
        // events coming through the channel, and process them here.
        // That way, race conditions are avoided, since this loop
        // does not run in that separate background thread.
        discoveryEventLoopJob = backgroundDiscoveryEventScope.launch {
            logger(LogLevel.DEBUG) { "Discovery event loop started" }

            while (true) {
                val (pumpAddress, eventType) = discoveryEventChannel.receive()

                when (eventType) {
                    EventType.NEW_PUMP -> {
                        logger(LogLevel.DEBUG) { "Found paired device with address $pumpAddress" }
                        onNewPump(pumpAddress)
                        performPairing(backgroundDiscoveryEventScope, pumpAddress)
                    }
                    EventType.PUMP_GONE -> {
                        logger(LogLevel.DEBUG) { "Previously paired device with address $pumpAddress removed" }
                        onPumpGone(pumpAddress)
                    }
                }
            }
        }

        bluetoothInterface.startDiscovery(
            Constants.BT_SDP_SERVICE_NAME,
            "ComboCtl SDP service",
            "ComboCtl",
            Constants.BT_PAIRING_PIN,
            {
                deviceAddress -> backgroundDiscoveryEventScope.launch {
                    discoveryEventChannel.send(Pair(deviceAddress, EventType.NEW_PUMP))
                }
            },
            {
                deviceAddress -> backgroundDiscoveryEventScope.launch {
                    discoveryEventChannel.send(Pair(deviceAddress, EventType.PUMP_GONE))
                }
            },
            {
                // Filter for Combo devices based on their address.
                // The first 3 bytes of a Combo are always the same.
                deviceAddress ->
                (deviceAddress[0] == 0x00.toByte()) &&
                (deviceAddress[1] == 0x0E.toByte()) &&
                (deviceAddress[2] == 0x2F.toByte())
            }
        )

        logger(LogLevel.DEBUG) { "Discovery started" }
    }

    /**
     * Stops any ongoing discovery.
     *
     * If no discovery is ongoing, this function does nothing.
     */
    fun stopDiscovery() {
        if (discoveryEventLoopJob == null) {
            logger(LogLevel.DEBUG) { "Attempted to stop discovery even though none is ongoing; ignoring call" }
            return
        }

        logger(LogLevel.DEBUG) { "Stopping discovery" }

        bluetoothInterface.stopDiscovery()

        discoveryEventLoopJob!!.cancel()
        discoveryEventLoopJob = null

        logger(LogLevel.DEBUG) { "Discovery stopped" }
    }

    /**
     * Establishes a regular connection to a previously paired pump.
     *
     * "Regular" means "not pairing". This is the type of connection
     * one uses for regular operation.
     *
     * Packets are received in a loop that runs in a background
     * coroutine that operates in the [backgroundReceiveScope].
     *
     * That scope's context needs to be associated with the same thread
     * this function is called in. Otherwise, the receive loop
     * may run in a different thread than this function, potentially
     * leading to race conditions.
     *
     * If an exception is thrown, the connection attempt is rolled
     * back. The device is in a disconnected state afterwards.
     *
     * @param pumpAddress Bluetooth address of the pump to connect to.
     * @param backgroundReceiveScope [CoroutineScope] to run the
     *        background packet receive loop in.
     * @param persistentState Persistent state store for this pump.
     * @param onNewDisplayFrame Callback invoked every time the pump
     *        receives a new complete remote terminal frame.
     * @throws ComboIOException if an IO error occurs during
     *         the connection attempts.
     * @throws IllegalStateException if the pump was not paired,
     *         or if the Bluetooth interface is not in a state that
     *         allows for getting access to Bluetooth devices, such
     *         as a Bluetooth subsystem that has been shut down.
     */
    suspend fun connect(
        pumpAddress: BluetoothAddress,
        persistentState: PersistentState,
        backgroundReceiveScope: CoroutineScope,
        onNewDisplayFrame: (displayFrame: DisplayFrame) -> Unit
    ): Pump {
        require(persistentState.isValid())

        logger(LogLevel.DEBUG) { "About to connect to pump $pumpAddress" }

        val bluetoothDevice = bluetoothInterface.getDevice(pumpAddress)

        val pump = Pump(
            bluetoothDevice,
            persistentState,
            onNewDisplayFrame
        )

        pump.connect(backgroundReceiveScope)

        return pump
    }

    private suspend fun performPairing(backgroundReceiveScope: CoroutineScope, pumpAddress: BluetoothAddress) {
        logger(LogLevel.DEBUG) { "About to perform pairing with pump $pumpAddress" }

        lateinit var persistentStateToFill: PersistentState

        try {
            persistentStateToFill = requestPersistentState(pumpAddress)
        } finally {
            logger(LogLevel.ERROR) { "Could not get persistent state for pump $pumpAddress" }
        }

        // TODO: What if user wants to abort the pairing?

        val bluetoothDevice = bluetoothInterface.getDevice(pumpAddress)
        logger(LogLevel.DEBUG) { "Got Bluetooth device for pump" }

        val pump = Pump(
            bluetoothDevice,
            persistentStateToFill,
            { Unit }
        )

        logger(LogLevel.DEBUG) { "Pump instance ready for pairing" }

        pump.performPairing(backgroundReceiveScope, bluetoothInterface.getAdapterFriendlyName()) {
            previousAttemptFailed, getPINDeferred -> pairingPINCallback(pumpAddress, previousAttemptFailed, getPINDeferred)
        }

        logger(LogLevel.DEBUG) { "Successfully paired with pump $pumpAddress" }
}
}
